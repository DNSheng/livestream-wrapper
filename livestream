#!/bin/bash

# A wrapper for livestreamer
# Supply your API token in the config file as explained by livestreamer's manual
# Dependencies:
#	- livestreamer
#	- GNU Parallel
#
# Alias notes:
# 	- Aliases must not include special characters (alphanum only)
#	- Aliases are case-sensitive
#	- Aliases are unique
#	- Aliases can not have same name as commands
#
# DNSheng, 2017

# TODO:
#	- Carry over arguments to livestreamer
#	- Display title of streams (not possible just using livestreamer)
#	- Prioritize ONLINE streams to top of list when pinging
#	- Strengthen alphanum alias restriction

# Location of channel list
channel="/home/$USER/.config/livestreamer/channels.txt"

# Help
help () {
	echo ""
	echo "livestream [COMMAND] [ARGUMENTS]"
	echo ""
	echo "An custom wrapper for livestreamer."
	echo "Options:"
	echo "	help	- Display help information."
	echo "	add	- Add an alias, or overwite an existing one [ALIAS] [CHANNEL_URL]"
	echo "	remove	- Remove a single alias, or all aliases associated with a URL [ALIAS/CHANNEL_URL]"
	echo "	list	- List all aliases and corresponding URLs"
	echo "	ping	- Ping all aliased channels, or a specific alias/channel"
	echo "		  for online availability"
	echo ""
	echo "Uses like livestreamer normally, but with added functionality (aliasing, pinging, etc.)"
	echo "livestream [CHANNEL] [QUALITY]"
	echo "If no [QUALITY] value entered, defaults to 'best'"
	echo "Enter the alias/url and quality like normal."
	echo "Currently, additional arguments do not carry over."
	echo "The alias file is located at $channel"
	echo ""
	echo "NOTE: - As additional arguments do not carry over, the"
	echo "        config file for livestreamer must be set."
	echo "      - The period character '.' cannot be included in an alias."
	echo "      - Aliases are unique and case-sensitive."
	echo ""
}

# Add a channel and alias
# Input:	[Alias URL]
add () {
	# Create new channel list if none found
	if [ ! -e $channel ]; then
		echo "Channel list does not exist, creating new list..."
		touch $channel
		echo "# Automatically generated channel list" >> $channel
		echo -e "# Format: [ALIAS] [CHANNEL URL]\n" >> $channel
	fi
	
	# Check if two arguments included
	if [[ $# -lt 2 ]]; then
		echo "Insufficient arguments..."
		exit
	fi

	# Check if alias exists
	_match $1
	if [[ $? == 2 ]]; then
		# Alias exists, overwrite prompt
		echo "Warning: Alias already exists. Overwrite? (Y/N)"
		read input
		if [[ $input == "Y" ]] || [[ $input == "y" ]]; then
			remove $1
			echo "Adding alias $1 to $2..."
			echo "$1 $2" >> $channel
		else
			echo "Exiting..."
		fi
	else
		# Check if alias contains '.'
		# TODO: Strengthen for alphanum only
		defense=$(echo $1 | grep '\.')
		if [[ $defense != "" ]]; then
			echo "Warning: Invalid alias (contains '.' character)"
			echo "Aborting..."
		else
			echo "$1 $2" >> $channel
		fi
	fi
}

# Remove a channel and alias
# Input:	Alias/URL
remove() {
	_match $1
	return_code=$?
	if [[ $return_code -eq 1 ]]; then 
		# This is really hacky, might not work for some sites
		hack=$(echo $1 | cut -d "/" -f 2)
		# Added '$' for end of line, otherwise every URL with that keyword is deleted
		sed -i "/$hack$/d" $channel
	elif [[ $return_code -eq 2 ]]; then
		sed -i "/$1 /d" $channel
	else
		echo "Alias/URL not found, exiting..."
	fi
}

# List all channels and their aliases
list() {
	warning=0
	affected=""

	printf "\n%-10s %-30s\n" "[ALIAS]" "[URL]"
	echo "----------------------------------------------------"

	while read -r line; do
		if [[ ${line:0:1} != "#" ]] && [[ $line != "" ]]; then
			alias=$(echo $line | cut -d " " -f 1)

			# Check for a '.' character in each alias
			# TODO: Check for all non-alphanum aliases
			defense=$(echo $alias | grep '\.')
			if [[ $defense != "" ]]; then
				warning=1
				# Append alias to list of affected
				affected="$affected $alias"
			fi

			url=$(echo $line | cut -d " " -f 2)
			printf "%-10s %-30s\n" "$alias" "$url"
		fi
	done < $channel
	
	if [[ $warning != 0 ]]; then
		echo ""
		echo "Warning: Invalid alias(es) found: $affected"
		echo "Please remove from the list"
	fi
	echo ""
}

# Scan through specific channel (if specified), or all channels, checking for activity
ping () {
	# TODO: Print error if invalid before the table below
	echo -e "\nOnline status:"
	printf "%-14s %-10s %-30s\n" "[STATUS]" "[ALIAS]" "[URL]"
	echo "----------------------------------------------------"

	if [[ $1 != "" ]]; then
		# Ping specific alias/url
		_determine $1
		if [[ $? == 0 ]]; then
			# Ping url
			# Get alias (if it exists)
			_alias_for_url $1
			if [[ $? == 0 ]]; then
				alias="[NONE]"
			fi
			_get_status $1
		else
			# Get alias and ping
			# Check existence of alias
			_match $1
			if [[ $? == 0 ]]; then
				echo "Alias not found: $1"
			else
				_url_for_alias $1
				_get_status $url
			fi
		fi
	else
		# Create a list of [ALIAS] and [URL]
		list=""
		while read -r line; do
			if [[ ${line:0:1} != "#" ]] && [[ $line != "" ]]; then
				alias=$(echo $line | cut -d " " -f 1)
				url=$(echo $line | cut -d " " -f 2)
				if [[ $list == "" ]]; then
					list="${alias} ${url}"
				else
					list="${list}\n${alias} ${url}"
				fi
			fi
		done < $channel
		# Export get_all_status() and _get_status() (due to dependency)
		export -f _get_status
		export -f _get_all_status
		# Use the list and feed to get_all_status in parallel
		# Tinker with -j# value
		echo -e "${list}" | parallel -j0 -k _get_all_status
	fi
	echo ""
}

# Get alias for URL from list
# Input:	URL
# Output:
#		0 - Alias not found
#		1 - Alias found
_alias_for_url() {
	while read -r line; do
		if [[ ${line:0:1} != "#" ]] && [[ $line != "" ]]; then
			url=$(echo $line | cut -d " " -f 2)
			if [[ $url == $1 ]]; then
				alias=$(echo $line | cut -d " " -f 1)
				return 1
			fi
		fi
	done < $channel
	return 0
}

# Get URL for alias from list
# Input:	Alias
# Output:	0 - URL not found
#		1 - URL found
_url_for_alias() {
	while read -r line; do
		if [[ ${line:0:1} != "#" ]] && [[ $line != "" ]]; then
			alias=$(echo $line | cut -d " " -f 1)
			if [[ $alias == $1 ]]; then
				url=$(echo $line | cut -d " " -f 2)
				return 1
			fi
		fi
	done < $channel
	return 0
}

# Get all status
# Input:	[Alias URL]
_get_all_status() {
	alias=$(echo $1 | cut -d " " -f 1)
	url=$(echo $1 | cut -d " " -f 2)

	_get_status $url
}

# Print the status of the channel
# Input:	URL
_get_status() {
	error=$(livestreamer -j $1 | grep error)
	if [[ $error != "" ]]; then
		printf "\e[0;31m%-14s\e[0m %-10s %-30s\n" "OFFLINE" "$alias" "$url"
	else
		printf "\e[0;32m%-14s\e[0m %-10s %-30s\n" "ONLINE" "$alias" "$url"
	fi
}

# Given either a URL or alias, check for existence in list
# Input:	URL/Alias
# Output:	0 - Neither found
#		1 - URL found
#		2 - Alias found
#		3 - Tag found		(CURRENTLY UNUSED)
_match() {
	while read -r line; do
		if [[ ${line:0:1} != "#" ]] && [[ $line != "" ]]; then
			alias=$(echo $line | cut -d " " -f 1)
			url=$(echo $line | cut -d " " -f 2)
			if [[ $url == $1 ]]; then
				return 1
			fi
			if [[ $alias == $1 ]]; then
				return 2
			fi
		fi
	done < $channel
	return 0
}

# Default behaviour, check if unknown command entered. Else, start stream
# Input:	[URL/Alias/Command Quality]
defensive() {
	_match $1
	match_val=$?
	# TODO: Strengthen for alpha num. checking
	url=$(echo $1 | grep '\.')
	
	# Only accept valid URL or alias
	if [[ $match_val == 0 ]] && [[ $url == "" ]]; then
		echo "Error: Unknown command"
		echo -e "Use the \"help\" command to display all commands."
	else
		_stream $1 $2
	fi
}

# Check for arguments and alias/url, start stream
# Input:	[URL/Alias {Quality}]
_stream() {
	if [[ $# -lt 1 ]]; then
		echo "No channel argument or alias supplied"
	else
		# Check if it is an alias or url given
		_determine $1
		is_alias=$?

		# Check if quality argument given, default 'best'
		if [[ $# == 1 ]]; then
			quality="best"
		else
			quality=$2
		fi
		
		if [[ $is_alias == 0 ]]; then
			livestreamer $1 $quality
		else
			_url_for_alias $1
			livestreamer $url $quality
		fi
	fi
}

# Distinguish between url and alias (URLs have a '.' char)
# Input:	URL/Alias
# Output:
#		0 - URL
#		1 - Alias
_determine() {
	url=$(echo $1 | grep '\.')
	if [[ $url == "" ]]; then
		return 1
	else
		return 0
	fi
}

# Main program
case $1 in
	"ping"		) ping $2;;
	"add"		) add $2 $3;;
	"remove"	) remove $2;;
	"list"		) list;;
	"help"		) help;;
	*		) defensive $1 $2;;
esac
